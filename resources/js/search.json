[[{"l":"Cryptography Notes","p":["A collection of notes on cryptography related subjects."]}],[{"l":"Introduction","p":["Information and images are taken from Crypto Corner. Additional sources are explicitly mentioned."]},{"l":"Steganography","p":["Steganography is the hiding of a message by a physical means. An example of steganography would be hiding a message in an image file's bytes."]},{"l":"Cryptography","p":["Cryptography is split into two ways of changing the message systematically to confuse anyone who intercepts it: these are codes and ciphers. Many people believe, and use, the word code to mean the same thing as cipher, but technically they are different.","Codes are ways of changing messages by replacing each word with another word that has a different meaning.","Ciphers convert messages by a rule, known only to the sender and recipient, which changes each individual letter (or sometimes groups of letters)"]},{"l":"Conventions","p":["plaintext= the message that is being encrypted","ciphertext= the encrypted message","alphabet= letters and symbols which will be transformed by the cipher"]}],[{"l":"Monoalphabetic Substitution Ciphers","p":["Information and images are taken from Crypto Corner. Additional sources are explicitly mentioned.","A monoalphabetic substitution is a cipher in which each occurrence of a plaintext symbol is replaced by a corresponding ciphertext symbol to generate ciphertext. ( Cornell University, Math 135, 2006)","Applying a monoalphabetic substitution cipher multiple times is equivalent to applying it once!","E is the encryption function. D is the decryption function."]},{"l":"Caesar cipher"},{"l":"Encryption","p":["Considering the 26-letter English alphabet and an integer key, 0 <= K < 26, encryption is done by shifting the alphabet to the left by K positions. For example, with K = 3, \"A\" would be encrypted to \"D\".","Mathematically, if i is the i-th letter in the zero-indexed English alphabet, then E(i, K) = i + K \\pmod{26}"]},{"l":"Decryption","p":["Decryption is the reverse process, that is shifting the alphabet to the right by K positions.","D(i, K) = i - K \\pmod{26}"]},{"l":"Observations","p":["Modulo is needed because we are limited to the 26-letter alphabet. Thus, a key of 1 is the same as a key of 27 because 1 \\pmod{26} = 27 \\pmod{26}.","Regarding the fact that applying a monoalphabetic substitution cipher multiple times is equivalent to applying it once:","E(E(i, K_{1}), K_{2}) = (i + K_{1} \\pmod{26}) + K_{2} \\pmod{26} = i + K_{1} + K_{2} \\pmod {26} = i + K_{3} \\pmod{26}"]},{"l":"Affine cipher","p":["The affine cipher is a generalization of the caesar cipher. Now, the alphabet is of dimension m, and there are two keys: a and b."]},{"i":"encryption-1","l":"Encryption","p":["E(x,a,b) = ax + b \\pmod{m}"]},{"i":"decryption-1","l":"Decryption","p":["D(x,a,b) = a^{-1}(x - b) \\pmod{m}","a and m have to be coprime, otherwise we can't compute a^{-1}.","Explanation (for details, see notes on modular arithmetics):"]},{"i":"observations-1","l":"Observations","p":["The Caesar cipher is the affine cipher with a = 1(and m = 26, if we only use letters from the English alphabet).","If, for example, m=26, the number of possible values for a is \\varphi(26)=12(see notes on Euler's totient function)). b can be any value that satisfies 0 <= b < 26. So the possible number of valid affine cipher keys if m=26 is 12 \\cdot 26 = 312."]},{"l":"Frequency Analysis","p":["The method behind frequency analysis is based on the letter frequency of the English alphabet. For example, the most common letter in the English alphabet is \"E\". Thus, if a message encrypted with a monoalphabetic substitution cipher is long enough, we can pretty safely assume that its most common letter is the ciphertext for \"E\". We can repeat this process for every letter in the frequency distribution (see image below).","Letter frequency in the English alphabet","Every single type of monalphabetic substitution is easily breakable using frequency analysis."]}],[{"l":"Hill Cipher","p":["Information and images are taken from Crypto Corner. Additional sources are explicitly mentioned.","The Hill cipher is a polygraphic (that acts on groups of letters, instead of one letter) substitution cipher that is based on matrix operations. This page is focused on 2\\times2(digraphic) and 3\\times3(trigraphic) variants of the Hill cipher, but it can be extended to more dimensions. The cipher is more easily explained with an example."]},{"l":"Encryption","p":["In this scenario, we will use with the English alphabet again. Each letter is represented by its index in the alphabet, starting from 0. We are working with modular operations again \\pmod{26}. For example, in a 2\\times2 Hill cipher scenario, let's consider the following 2\\times2 key:","K = \\begin{pmatrix} H && I \\\\ L && L \\end{pmatrix} = \\begin{pmatrix} 7 && 8 \\\\ 11 && 11 \\end{pmatrix}","The message \"short example\" will be encrypted. Spaces will be taken out and letters will be written into digraphs represented by 2-dimensional vectors, as such:","M = \\begin{pmatrix} S \\\\ H \\end{pmatrix} \\begin{pmatrix} O \\\\ R \\end{pmatrix} \\begin{pmatrix} T \\\\ E \\end{pmatrix} \\begin{pmatrix} X \\\\ A \\end{pmatrix} \\begin{pmatrix} M \\\\ P \\end{pmatrix} \\begin{pmatrix} L \\\\ E \\end{pmatrix} = \\begin{pmatrix} 18 \\\\ 7 \\end{pmatrix} \\begin{pmatrix} 14 \\\\ 17 \\end{pmatrix} \\begin{pmatrix} 19 \\\\ 4 \\end{pmatrix} \\begin{pmatrix} 23 \\\\ 0 \\end{pmatrix} \\begin{pmatrix} 12 \\\\ 15 \\end{pmatrix} \\begin{pmatrix} 11 \\\\ 4 \\end{pmatrix}","To encrypt each digraph, we perform a matrix multiplication. 2-dimensional matrix multiplication is performed in the following way:","\\begin{pmatrix} a && b \\\\ c && d \\end{pmatrix} \\begin{pmatrix} x && y \\end{pmatrix} = \\begin{pmatrix} ax + by \\\\ cx + dy\\end{pmatrix}","When we multiply two matrices, there are two things to keep in mind:","the first matrix's column number must be equal to the second matrix's row number","if the first matrix is of dimension (M, N) and the second matrix is of dimension (N, P), their product is of dimension (M, P)","The first encrypted digraph is computed as follows:","\\begin{pmatrix} 7 && 8 \\\\ 11 && 11 \\end{pmatrix} \\begin{pmatrix} 18 \\\\ 7 \\end{pmatrix} = \\begin{pmatrix} 182 \\\\ 275 \\end{pmatrix} \\pmod{26} = \\begin{pmatrix} 0 \\\\ 15 \\end{pmatrix} = \\begin{pmatrix} A \\\\ P \\end{pmatrix}","Remember we are in the the English alphabet, so we must apply modulus. Each digraph is encrypted like the above operation. After encryption, we can switch back from letter indexes to letters."]},{"l":"Decryption","p":["For decrpytion, we must compute the inverse of the key matrix.","K^{-1} = d^{-1} \\times adj(K), where d^{-1} is the multiplicative modular inverse of K's determinant, and adj(K) is K's adjugate matrix.","d = \\begin{vmatrix} a && b \\\\ c && d \\end{vmatrix} = ad - bc","To be invertible, a matrix must have a non-zero determinant and, since we are working in the ring of integers modulo 26, the determinant must be coprime with 26.","In general, the determinant must be coprime with the alphabet's length.","adj\\begin{pmatrix} a && b \\\\ c && d \\end{pmatrix} = \\begin{pmatrix} d && -b \\\\ -c && a \\end{pmatrix}","After computing K^{-1}, we multiply it with each encrypted digraph to get back to the plaintext. For the example above:","d(K) = \\begin{vmatrix} 7 && 8 \\\\ 11 && 11 \\end{vmatrix} = 7 \\cdot 11 - 8 \\cdot 11 = -11 \\pmod {26} = -11 + 26 \\pmod{26} = 15 \\pmod {26}","d^{-1} = 15^{-1} \\pmod {26} = 7 \\pmod {26}, which is a non-zero number coprime with 26.","adj(K) = \\begin{pmatrix} 11 && -8 \\\\ -11 && 7 \\end{pmatrix} \\pmod{26} = \\begin{pmatrix} 11 && 18 \\\\ 15 && 17 \\end{pmatrix} \\pmod{26}","K^{-1} = 7\\begin{pmatrix} 11 && 18 \\\\ 15 && 17 \\end{pmatrix} = \\begin{pmatrix} 77 && 126 \\\\ 165 && 49 \\end{pmatrix} \\pmod{26} = \\begin{pmatrix} 25 && 22 \\\\ 1 && 23 \\end{pmatrix} \\pmod{26}","Let's try decrypting the first encrypted digraph, \\begin{pmatrix} A \\\\ P \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 15 \\end{pmatrix}","K^{-1}\\begin{pmatrix} 0 \\\\ 15 \\end{pmatrix} = \\begin{pmatrix} 25 && 22 \\\\ 1 && 23 \\end{pmatrix} \\begin{pmatrix} 0 \\\\ 15 \\end{pmatrix} = \\begin{pmatrix} 25 \\cdot 0 + 22 \\cdot 15 \\\\ 1 \\cdot 0 + 23 \\cdot 15 \\end{pmatrix} = \\begin{pmatrix} 330 \\\\ 345 \\end{pmatrix} \\pmod{26} = \\begin{pmatrix} 18 \\\\ 7 \\end{pmatrix} \\pmod{26} = \\begin{pmatrix} S \\\\ H \\end{pmatrix}"]}],[{"l":"Vigenère Cipher","p":["Information and images are taken from Crypto Corner. Additional sources are explicitly mentioned.","The Vigenère cipher is a polyalphabetic substitution cipher, meaning it uses multiple substitution alphabets. The cipher makes use of a table of alphabets called tabula recta. The tabula recta consists of the English alphabet written 26 times in different rows, each row being shifted one position to the left compared to the previous row (the first row is just the plain English alphabet). So, all rows actually make up the 26 possible Caesar cipher alphabets, starting from the first one with shift 0 and ending with the last one with shift 25. Yet again, the cipher alphabet is made up of the 26 English letters.","The rows and columns are indexed using the letters of the alphabet. Thus, the first row corresponds to A, the last one to Z and the same for columns.","Tabula Recta (source: Wikipedia)"]},{"l":"Encryption","p":["The key used for encryption is a word. To encrypt a message, we place the key under the plaintext (from which spaces and other non-alphabet characters were stripped) and we repeat the key until we \"cover\" all of the plaintext message. For example, if the plaintext message is \"a simple example\" and the key is \"battista\", we would get this:","Each pair of message and key characters gets encrypted to the character in tabula recta that corresponds to the row indicated by the plaintext character and the column indicated by the key character.","Mathematically speaking, Vigenère encryption E using key K can be written as:","C_{i} = E_{k}(M_{i}) = M_{i} + K_{i} \\pmod{26}","where M = M_{1}M_{2}...M_{n} is the plaintext, K = K_{1}K_{2}...K_{n} is the repeated key, and C = C_{1}C_{2}...C_{n} is the ciphertext."]},{"l":"Decryption","p":["Decryption is done by reverting the process for encryption. We write the repeated key under the ciphertext and each pair of ciphertext and key characters and perform the following:","identify the column with the corresponding key character \"index\" (letter index)","the row \"index\" which contains the ciphertext is the plaintext character","Mathematically speaking,","M_{i} = C_{i} - K_{i} \\pmod{26}"]},{"l":"Breaking the Unbreakable Cipher","p":["For long, the Vigenère cipher was thought to be unbreakable. Its most important strength is the fact that it is immune to frequency analysis because multiple alphabets are used in encryption so a plaintext character doesn't always get encrypted to the same ciphertext character. Its weakness lies in the repetition of the key. The cipher was broken by Friedrich Kasisksi."]}],[{"l":"Introduction","p":["Information and images are taken from Understanding Cryptography. Additional sources are explicitly mentioned.","Modern cryptography is split as follows:","Symmetric ciphers","Stream ciphers (encryption is done bit by bit, each time using a new bit from key)","Block ciphers (encryption is done in a block of bits, each time with the same key)","Assymetric (Public-Key) ciphers","Protocols"]}],[{"l":"Stream Ciphers","p":["Information and images are taken from Understanding Cryptography. Additional sources are explicitly mentioned."]},{"l":"Introduction","p":["In practice, block ciphers are used more than stream ciphers.","How do stream ciphers work? It's simple: each plaintext bit x_{i} is encrypted by adding a keystream bit s_{i} modulo 2 (which is the equivalent of XOR).","Encryption: y_{i} = x_{i} + s_{i} \\pmod{2}","Decryption: x_{i} = y_{i} + s_{i} \\pmod{2}","Encryption and decryption are actually the same function.","Generation of values s_{i} is the central issue for the security of stream ciphers"]},{"l":"RNG and One-Time Pad"},{"i":"true-random-number-generators-trng","l":"True random number generators (TRNG)","p":["their output cannot be reproduced","based on physical processes, such as flipping a coin, throwing dice, or, more realistically, semiconductor noise, clock jittering, radioactive decay","in cryptography, they are needed for generation of session keys"]},{"i":"pseudorandom-number-generators-prng","l":"Pseudorandom number generators (PRNG)","p":["they generate sequences starting from an initial value called seed","their output is not random at all, but entirely deterministic","however, their output should approximate a sequence of true random numbers as well as possible"]},{"i":"cryptographically-secure-pseudorandom-number-generators-csprng","l":"Cryptographically secure pseudorandom number generators (CSPRNG)","p":["they are special PRNGs that have an important property: their output is not predictable","given n bits of a keystream generated by a CSPRNG:","no polynomial algorithm can predict the n+1 th bit with better than 50% chance of success","the previous n-1 bits shouldn't be predictable either"]},{"l":"One-time pad","p":["A cryptosystem is unconditionally or information-theoretically secure if it cannot be broken even with infinite computational resources.","A One-Time Pad (OTP) is a stream cipher for which:","the keystream is generated by a TRNG","the keystream is only known by the communicating parties","every keystream bit is only used once","The OTP is unconditionally secure. However, its main disadvantage is the fact that the key's length needs to be equal to the message's length because every keystream bit is only used once. To create a real-world implementation of OTP, an idea is to use a CSPRNG with a secret key as its seed in order to generate the keystream."]},{"l":"Shift Register-Based Stream Ciphers","p":["An elegant way of realizing long pseudorandom sequences is to use linear feedback shift registers (LFSRs). Even though a plain LFSR produces a sequence with good statistical properties, it is cryptographically weak. However, combinations of LFSRs, such as A5/1 or the cipher Trivium, can make secure stream ciphers.","An LFSR consists of clocked storage elements (flip-flops) and a feedback path. An LFSR with m flip-flops is said to be of degree m. The leftmost state bit is computed in the feedback path, which is the XOR sum of some of the flip-flop values in the previous clock period. Since the XOR is a linear operation, such circuits are called linear feedback shift registers."]}],[{"l":"DES","p":["Information and images are taken from Understanding Cryptography. Additional sources are explicitly mentioned.","Confusion is an encryption operation where the relationship between key and ciphertext is obscured. Confusion can be achieved through substitution.","Diffusion is an encryption operation where the influence of one plaintext symbol is spread over many ciphertext symbols with the goal of hiding statistical properties of the plaintext. Diffusion can be achieved through transposition.","Ciphers which only perform confusion are not secure. Neither are ciphers which only perform diffusion. However, through the concatenation of such operations, a strong cipher can be built."]},{"l":"Overview","p":["DES is a symmetric block cipher with 64-bit block size and 56-bit key size.","DES is an iterative algorithm, with encryption being handled in 16 rounds each performing the same operation. The subkey k_{i} for each round is derived from the main key k. The underlying structure of DES is called a Feistel network.","Structure of DES","After the initial bitwise permutation IP of a 64-bit plaintext x, the plaintext is split into two halves L_0 and R_0. These two 32-bit halves are the input to the Feistel network, which consists of 16 rounds. The right half R_i is fed into the function f. The output of the f function is XORed (denoted by the symbol \\oplus) with the left 32-bit half L_i. Finally, the right and left half are swapped. This process repeats in the next round. Generally:","After round 16, the 32-bit halves L_{16} and R_{16} are swapped again, and the final permutation IP^{−1} is the last operation of DES. As the notation suggests, IP^{−1} is the inverse of the initial permutation IP. In each round, a round key k_{i} is derived from the main 56-bit key using what is called the key schedule."]},{"l":"Internal Structure"},{"l":"Initial and final permutations","p":["These are just basic bitwise permutations. Both permutations do not increase the security of DES at all. The exact rationale for the existence of these two permutations is not known, but it seems likely that their original purpose was to arrange the plaintext, ciphertext and bits in a bytewise manner to make data fetches easier for 8-bit data busses, which were the state-of-the-art register size in the early 1970s."]},{"i":"-function","l":"f function","p":["The f function plays a crucial role for the security of DES. In round i it takes the right half R_{i−1} of the output (32 bits) of the previous round and the current round key k_i as input. The output of the f function is used as an XOR-mask for encrypting the left half input bits L_{i−1}.","In short, the steps performed are:","expansion of the 32-bit input to 48 bits using a speciall type of permutation called E-box","48-bit result is XOR-ed with k_{i}","result is divided in eight 6-bit blocks and fed into eight different S\\text{-}boxes(substitution boxes). Each S-box maps a 6-bit input to a 4-bit output, which causes confusion","finally, the 32-bit (eight 4-bit S-box outputs) output is fed into a permutation called P, which causes diffusion","DES f function","The S-box is the most crucial element of DES because it introduces non-linearity"]},{"l":"Key schedule","p":["The key schedule derives 16 round keys k_i, each consisting of 48 bits, from the original 56-bit key. Another term for round key is subkey. First, note that the DES input key is often stated as 64-bit, where every eighth bit is used as an odd parity bit over the preceding seven bits. It is not quite clear why DES was specified that way. In any case, the eight parity bits are not actual key bits and do not increase the security. DES is a 56-bit cipher, not a 64-bit one."]},{"l":"Decryption","p":["One advantage of DES is that decryption is essentially the same function as encryption. This is because DES is based on a Feistel network."]},{"l":"Security","p":["DES is not considered secure anymore because of the small key size. However, 3DES (triple-DES, which means three successive DES applications) is still used and viable."]}],[{"l":"AES","p":["Information and images are taken from Understanding Cryptography. Additional sources are explicitly mentioned."]},{"l":"Overview","p":["# rounds = n_r","10","12","128-bit","14","192-bit","256-bit","AES is a symmetric block cipher with 128-bit block size and three possible key lenghts: 128, 192, and 256-bit. AES does not have a Feistel structure, in contrast to DES. Feistel networks don't encrypt whole blocks in each iteration (only half-blocks), however, AES does encrypt whole 128-bit blocks in each iteration. Encryption is done in rounds, just like DES. The number of rounds depends on the key length:","AES is based on three types of layers. Each round, with the exception of the first, employs all three layers. Additionally, the last round doesn't make use of the MixColumn transformation for symmetry purposes. The three layers are:","Byte Substitution layer(S-box): each state element is non-linearly transformed using look-up tables. This produses confusion","Diffusion layer:","Key Addition layer: a 128-bit subkey derived from the main key is XORed to the current state","Key length","MixColumn sublayer: mixes blocks of four bytes","ShiftRows sublayer: permutes data on byte level","Structure of AES"]},{"l":"Internal Structure"},{"l":"Byte substitution layer","p":["This is the first layer in each round. It can be viewed as a row of 16 parallel S-boxes, each with 8 bits as input and output. All S-boxes are identical, unlike DES, where eight different S-boxes are used. The S-box is also a bijective mapping, which means it's reversible.","The S-box is the only non-linear element of AES. That is, S\\text{-}box(A) + S\\text{-}box(B) \\neq S\\text{-}box(A + B) for two states A and B."]},{"l":"Diffusion layer","p":["In AES, the Diffusion layer consists of two sublayers, the ShiftRows transformation and the MixColumn transformation. The Diffusion layer performs a linear operation."]},{"l":"ShiftRows sublayer","p":["The ShiftRows transformation cyclically shifts the second row of the state matrix by three bytes to the right, the third row by two bytes to the right and the fourth row by one byte to the right."]},{"l":"MixColumn sublayer","p":["The MixColumn step is a linear transformation which mixes each column of the state matrix. Since every input byte influences four output bytes, the MixColumn operation is the major diffusion element in AES."]},{"l":"Key addition layer","p":["The two inputs to the Key addition layer are the current 16-byte state matrix and a subkey which also consists of 16 bytes (128 bits). The two inputs are combined through a bitwise XOR operation."]},{"l":"Key schedule","p":["The key schedule takes the original input key (of length 128, 192 or 256 bit) and derives the subkeys used in AES. Note that an XOR addition of a subkey is used both at the input and output of AES.","The number of subkeys is equal to the number of rounds plus one, due to the key needed for key whitening in the first key addition layer."]},{"l":"Decryption","p":["Because AES is not based on a Feistel network, all layers must actually be inverted, i.e., the Byte Substitution layer becomes the Inv Byte Substitution layer, the ShiftRows layer becomes the Inv ShiftRows layer, and the MixColumn layer becomes Inv MixColumn layer."]}],[{"i":"#","p":["Operations with modulus"]},{"l":"Modular Arithmetics"},{"l":"Basic operations","p":["If a + b = c then a \\pmod{m} + b \\pmod{m} \\equiv c \\pmod{m}","If a \\cdot b = c then a \\pmod{m} \\cdot b \\pmod{m} \\equiv c \\pmod{m}","For modulus of negative numbers with respect to m, we must add m to the negative number until we get a number which is between 0 and m. For example, -8 \\pmod{5} = -8 + 5 \\pmod{5} = -3 \\pmod{5} = -3 + 5 \\pmod{5} = 2 \\pmod{5}."]},{"l":"Modular multiplicative inverse","p":["A modular multiplicative inverse of a with respect to modulus m, denoted a^{-1} exists if aa^{-1} \\equiv 1 \\pmod {m}.","a^{-1} exists if and only if gcd(a, m) = 1, that is, a and m are relatively prime or coprime. Thus:","If m is prime, for each 0 < a < m, there exists a modular multiplicative inverse a^{-1}."]},{"i":"eulers-totient-function","l":"Euler's totient function","p":["Two numbers are coprime if they don't share any divisors other than 1.","Used to find number of numbers coprime to a given number smaller than that number. In short, the number of numbers comprime to n and smaller than n is:","\\varphi(n)= n \\cdot (1-\\frac{1}{p_{1}}) \\cdot (1-\\frac{1}{p_{2}}) \\cdot ... \\cdot (1-\\frac{1}{p_{k}})","where p_1, p_2, ..., p_k are the distinct prime factors of n(that is, n = p_{1}^{e_1} \\cdot p_{1}^{e_1} \\cdot ... \\cdot p_{k}^{e_k}).","For example, \\varphi(20) = 20\\cdot(1-1/2)\\cdot(1-1/5) = 20\\cdot(1/2)\\cdot(4/5) = 8 because 20 = 2^2\\cdot 5. The numbers coprime to 20 and smaller than 20 are 3, 5, 7, 9, 11, 13, 17, 19.","\\varphi(26) = 26\\cdot(1-1/2)\\cdot(1-1/13) = 26\\cdot(1/2)\\cdot(12/13)=12."]},{"i":"fermats-little-theorem","l":"Fermat's little theorem","p":["If p is prime, then, for any integer a the following holds:","a^p \\equiv a \\pmod{p}","If p and a are coprime, then:","a^{p-1} \\equiv 1 \\pmod{p}","If a and p are coprime, a^{-1} \\equiv a^{p-2} \\pmod{p}"]}]]